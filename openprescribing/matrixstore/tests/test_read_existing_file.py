from itertools import product
from random import Random
import os
import platform
import sqlite3
import subprocess
import sys

from django.test import SimpleTestCase

import numpy

from matrixstore.matrix_ops import sparse_matrix, finalise_matrix
from matrixstore.serializer import (
    deserialize, serialize, serialize_compressed
)


class TestReadExistingFile(SimpleTestCase):
    """
    This tests that we can still correctly read serialized matrices (sparse,
    dense, compressed and uncompressed) from an SQLite fixture created by a
    previous version of the software. This should catch any backwards
    incompatibilities introduced by upgrading our dependencies, in particular
    PyArrow. The fixture file can be regenerated by calling the
    `create_fixture` class method on this class.
    """

    fixture_path = 'matrixstore/tests/fixtures/read_existing_file.sqlite'

    def test_values_can_be_read_correctly(self):
        connection = self.get_fixture_connection()
        for key, expected_value in self.get_expected_values():
            result = connection.execute(
                'SELECT value FROM data WHERE key=?', [key]
            )
            value = deserialize(result.fetchone()[0])
            self.assertIsInstance(value, type(expected_value))
            if hasattr(value, 'todense'):
                value = value.todense()
                expected_value = expected_value.todense()
            self.assertEqual(value.tolist(), expected_value.tolist())

    def get_fixture_connection(self):
        if not os.path.exists(self.fixture_path):
            raise RuntimeError(
                'No SQLite file at: {fixture_path}\n\n'
                'To create the fixture, run:\n'
                '  ./manage.py shell -c'
                '  "from {module} import {cls}; {cls}.create_fixture()"'
                .format(
                    fixture_path=self.fixture_path,
                    module=__name__,
                    cls=self.__class__.__name__
                )
            )
        return sqlite3.connect(self.fixture_path)

    @classmethod
    def get_expected_values(cls):
        random = Random()
        random.seed(1204)
        for sparse, integer, compressed in product([True, False], repeat=3):
            matrix = cls.make_matrix(random, sparse, integer)
            key = '{structure}.{type}.{format}'.format(
                structure='sparse' if sparse else 'dense',
                type='integer' if integer else 'float',
                format='compressed' if compressed else 'uncompressed'
            )
            yield key, matrix

    @classmethod
    def make_matrix(self, random, sparse, integer):
        shape = (4, 4)
        if sparse:
            matrix = sparse_matrix(shape, integer=integer)
        else:
            dtype = numpy.int_ if integer else numpy.float_
            matrix = numpy.zeros(shape, dtype=dtype)
        coords = map(random.randrange, shape)
        value = random.randrange(128) if integer else random.random()
        matrix[coords] = value
        if sparse:
            matrix = finalise_matrix(matrix)
        return matrix

    @classmethod
    def create_fixture(cls):
        temp_file = cls.fixture_path + '.tmp'
        if os.path.exists(temp_file):
            os.unlink(temp_file)
        connection = sqlite3.connect(temp_file)
        connection.executescript(
            """
            CREATE TABLE data (key TEXT, value BLOB);
            CREATE TABLE environment_metadata (key TEXT, value TEXT);
            """
        )
        for key, value in cls.get_expected_values():
            if '.uncompressed' in key:
                data = serialize(value)
            elif '.compressed' in key:
                data = serialize_compressed(value)
            else:
                raise RuntimeError('Invalid key')
            connection.execute(
                'INSERT INTO data VALUES (?, ?)',
                [key, sqlite3.Binary(data)]
            )
        for key, value in cls.get_environment_metadata():
            connection.execute(
                'INSERT INTO environment_metadata VALUES (?, ?)',
                [key, value]
            )
        connection.commit()
        connection.close()
        os.rename(temp_file, cls.fixture_path)

    @classmethod
    def get_environment_metadata(cls):
        """
        Yields various bits of metadata about the current environment (Python
        version, installed package versions etc) which might be useful in
        debugging failures
        """
        yield 'python_version', platform.python_version()
        yield 'platform', platform.platform()
        installed_packages = subprocess.check_output(
            [sys.executable, '-m', 'pip', 'freeze', '-qqq']
        )
        yield 'installed_packages', installed_packages
